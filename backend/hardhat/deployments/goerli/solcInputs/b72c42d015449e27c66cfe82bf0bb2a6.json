{
  "language": "Solidity",
  "sources": {
    "contracts/Signing.sol": {
      "content": "//SPDX-License-Identifier:MIT\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\n//This is the contract address\r\n//0xFB295f887882beEC3FE11dEa259E59D237914A08\r\n\r\n//This is the link\r\n//\r\n\r\n\r\ncontract Signing{\r\n\r\n    //This is the verify function which takes three inputs\r\n    //1-) The address of the message signer\r\n    //2-)The message that was signed by the signer\r\n    //3-) The hash of the signed message\r\n\r\n    function verify(address _sender,string memory _message,bytes memory hash) external pure returns(bool)\r\n    {\r\n        //Now from the following two functions we are obtaining the hashed message that was signed by the signer off chain\r\n        bytes32 signedMessagehash=getMessageHash(_message);\r\n        bytes32 signedEthMessagehash=getSignedEthMessageHash(signedMessagehash);\r\n\r\n        // The signedEthMessagehash is the message that was signed off chain by the sender of the message\r\n\r\n        //Now we once we have the signed message and the signature we can create a verify function to get the signer\r\n        bool isit=recoverSigner(signedEthMessagehash,hash)==_sender;\r\n        require(isit,\"There was some problem in signing the smart contract\");\r\n        return isit;\r\n    }\r\n\r\n    function getMessageHash(string memory _message) public pure returns(bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_message));\r\n    }\r\n\r\n    function getSignedEthMessageHash(bytes32 _message) public pure returns(bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\",_message));\r\n    }\r\n\r\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\r\n        public\r\n        pure\r\n        returns (address)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig)\r\n        public\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            /*\r\n            First 32 bytes stores the length of the signature\r\n\r\n            add(sig, 32) = pointer of sig + 32\r\n            effectively, skips first 32 bytes of signature\r\n\r\n            mload(p) loads next 32 bytes starting at the memory address p into memory\r\n            */\r\n\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // implicitly return (r, s, v)\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}